/*
 * DDS-2.1.c
 *
 * Created: 07.04.2021 18:03:57
 * Author : Red
 */ 


#define F_CPU 3579545UL
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>

#include "main.h"


int fire =0;                //пуск авто

int preasure=0;             //сработка датчика давления
int volts=0;    // Напряжение питания 


int k=5;

int timing;

char read_enable = 0;




  //----------------Работа прерывателя таймера------------------------------------

 ISR (TIMER1_COMPA_vect)
 {
	  timing++;
	  Omega_slave(); 
  }
 

int main(void)
{  
	
	
	
	ADCSRA|=(1<<ADEN);// разрешаем работу АЦП
	ADMUX &= (0 << REFS1);
	ADMUX|=(1 << REFS0); //выставляем внешнее  опорное напряжение
	ADMUX |= ~(1 <<ADLAR);//Правостороннее выравнивание
	ADCSRA |=(0<<ADPS0)|(1<<ADPS1)|(1<<ADPS2)|(0<<ADFR); //частота предделителя
   // ACSR |= (1 << ACD);//отключаем аналоговый компаратор
    // Настройка портов ввода/вывода
    DDRC = 0b00000000;
	DDRB = 0b00111010;
	PORTB= 0b00000000;
    DDRD = 0b11111111;
	PORTC= 0b00000000;
	PORTD= 0b00000000;
//_________________________________________________________________________________________________
    
	TCCR1B |= (1<<WGM12); // устанавливаем режим СТС (сброс по совпадению)
	TIMSK |= (1<<OCIE1A);	//устанавливаем бит разрешения прерывания 1ого счетчика по совпадению с OCR1A(H и L)
	OCR1A = 100;  //записываем в регистр число для сравнения
	TCCR1B |= (1<<CS11);//установим делитель.
	
	
	
	
	
	
	adress=19;
	device_ID=25;// 157-блок коммутации ,89-СПРА ,108-БСА, 25 -СПДОТА
//===================================================================================================================================================	
 
 
 k=EEPROM_read(0x03);          // ОТКЛОНЕНИЕ НАПРЯЯЖЕНИЙ
 
 delta_U=EEPROM_read(0x08);	 
 if(delta_U>42){delta_U=41;}       // Определение значений по умолчанию
 delta_F=EEPROM_read(0x09);
 if(delta_F>42){delta_F=41;}
 //adress=EEPROM_read(0x10);
 //if(adress>128){adress=0;}
 
 
 
 
  // fire=read_adc(0); //Чтение состояния входа ПОЖАР
// preasure=read_adc(1); // Состояние входа ВЫХОД НА РЕЖИМ



  sei();

    while (1) 
	
  {
	  if(timing>=10000){
	   cli(); 
	 smoke=read_adc(0);
	PORTB|=(1<<PB3);
	//_delay_us(20);
	fire=read_adc(0); //Чтение состояния входа ПОЖАР
	sei();
	current=read_adc(6); //Ток светодиода
	PORTB&=~(1<<PB3);
	timing=0;
}
	
	volts =read_adc(7); // Чтение напряжения питания 
	//current=read_adc(6); //Ток светодиода
	//PORTB&=~(1<<PB3);
	_delay_ms(200);
  }
  
  
  
 }